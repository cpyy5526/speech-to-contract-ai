# 시스템 상세 설계

지난 중간발표1 시점 기준에서 추가 또는 구체화된 것들 위주로 정리했습니다.

## 1.  내부 API 정의

- 서버 내부 동작에 맞게 엔드포인트 목록 구분
- 모든 요청에 대해 언제 사용하는지와 요청 및 성공 시 응답의 JSON 데이터 형식을 구체적으로 정의함
    - FastAPI 메인 서버 코드를 바로 작성할 수 있는 기반 → 구현 단계에서 예상되는 시간 소모를 줄임
- 각 엔드포인트의 실패 케이스도 최대한 자세히 구분해 두었음
    - 구현 단계에서의 예외 처리 난이도를 낮추고 시간 소모를 줄임

## 2.  비동기 파이프라인**

- 음성 파일 업로드, 음성-텍스트 변환(Whisper 변환), 내부 로직을 통한 계약서 생성은 기본적으로 수십 초에서 수 분 정도 소요될 수 있는 작업
- 일반적인 “요청 → 작업 완료 → 응답” 방식으로는 실패 확률이 높아지며, 모바일 환경을 우선으로 고려하는 프로젝트 특성상 시스템이 전체적으로 불안정해질 가능성이 높음 → 사용자 경험 측면에서도 좋지 않음
- **Polling 기반 비동기 흐름 도입:** 음성 업로드 및 변환, 계약서 생성은 **비동기 작업 처리 + 상태 추적** 방식으로 분리함 → 실제 주요 작업은 서버 백그라운드에서 진행되고 프론트엔드에서는 클라이언트는 상태 확인
    1. 클라이언트에서 음성 업로드 및 텍스트 변환(또는 계약서 생성) 시작 요청 서버에 접수
    2. 서버에서는 접수했음을 응답하고 작업을 내부적으로 진행
    3. 클라이언트에서는 작업 진행 상황을 조회하는 요청을 서버에 수 초마다 보내면서 추적하고(→ Polling), 서버에서는 “uploading”, “transcribing”, “generating”, “done”, “failed”와 같이 응답함
    4. 클라이언트에서는 작업이 완료되거나 실패했음을 확인한 후에 다음 요청 또는 로직으로 넘어감

## 3.  계약서 데이터 저장 방식**

**DB에서 계약서 전체를 JSON 형태로 한 컬럼에 저장** (contracts_contents.contents)

- 계약서는 유형이 다양하고, 유형마다 항목이 다름
    - 각 유형마다 개별 테이블을 구성하면 너무 많아져서 DB 설계가 복잡해지고 유지보수가 어려워짐
- 실제 복잡한 법적 맥락을 검토하기 위해 (법률에 전문적인) 멘토님의 지속적인 피드백 예정
    - 계약 유형별 항목이 실제 구현 도중에도 여러 차례 수정될 수 있어서, 테이블 스키마로 고정하기에는 현실적인 어려움이 있음
- 계약서의 각 항목은 GPT가 채워넣고, 사용자가 조회하고 수정하는 정도의 ‘단순 편집 대상’ (공란의 제안 텍스트 역시 초기 생성에만 발생하고, 특정 필드에 대해 ‘제안 문자열’을 표시하도록 구현할 예정)
    - 현재 프로젝트 범위에서 계약서 내용은 내부적으로 조합하고 연산(정렬, 통계, 데이터 검증)하는 대상은 아님
- 클라이언트에서는 계약서 JSON 전체를 받아 배치 및 시각화하고 PDF 문서화
    - JSON을 통째로 관리하면 프론트엔드와의 연동에 오히려 더 유리
- 사용 기술 스택인 PostgreSQL에서는 JSONB 타입을 지원하여, 효과적으로 조회 및 관리 가능
- 불필요하게 설계 및 구현이 복잡해지지 않도록 막고, 요구사항과 현재 진행상황에 맞게 적절하게 단순화

## 4.  대용량 데이터 처리 전략

- **계약서 생성 이후 원본 녹음파일과 변환된 대화 텍스트 파일은 보관하지 않고 자동으로 삭제**
    - 음성 40MB(모바일 기준 대략 30-35분 정도 분량) 제한, 변환 텍스트 역시 최대 수만 자 분량 가능
    - 초기 멘토님과의 논의에서 ‘계약서 초안 생성’ 자체에만 초점을 맞추도록 결정했고, 생성된 계약서의 심층적인 법적 책임과 실제 효력 증명에 관한 문제는 프로젝트의 범위가 아님을 확인 → 구두계약 원본(대화 기록)을 굳이 증거로써 보관할 필요 없음
    - 음성 원본과 변환된 대화 텍스트는 계약서 초안 생성을 위한 일시적 데이터(중간 산출물)
    - 개인정보 보관 및 관리 책임, 대용량 파일 저장 부담 문제 최소화
- **DB에 대화 텍스트 전체를 직접 저장하는 대신, 서버 내부에 파일로 저장하고 DB에는 파일명만 기록하면서 추적**
    - 수만 자에 달하는 대화 텍스트를 DB에 직접 저장하도록 구현하면 성능이 크게 저하되어 시스템 전체 응답 시간 증가
    - DB에서는 파일의 메타 정보만 추적, 실제 본문은 파일 기반으로 관리
- **백엔드 내부 계약서 생성 로직에서 대화 텍스트를 문자열 형태가 아니라 파일 스트림 형태로 입출력 처리**
    - 과도한 메모리 사용량 증가 및 누수를 막고 입출력 병목 방지
    - 대량의 텍스트에도 시스템이 견고하게 작동할 수 있는 기반

## 5.  외부 API 호출 통제

- 의존성 주입(Dependency Injection): 하위 모듈에서 직접적인 GPT API 호출이 일어나지 않도록 설계
- 서버 메인 모듈에서만 발생하도록 통제 → 테스트, 예외 처리, 보안 통제가 쉬워짐
- 프롬프트 역할과 백엔드 역할의 구현 및 책임 범위를 명확하게 구분

## 6.  기초적인 보안 설계(요청-응답 계층 보안)

- **HTTPS(SSL/TLS) 프로토콜 사용: 클라이언트-서버 간 모든 데이터 전송 암호화**
    - 현재 대부분의 웹 서비스에서 사용되는 방식
    - 모든 통신 암호화: 비밀번호, 비밀번호 재설정 링크, 녹음 파일, 계약서 데이터 등 민감한 정보를 포함하여 모든 정보가 암호화되어 전송됨
    - 클라이언트-서버 간 통신 자체를 암호화하므로 네트워크 수준에서의 보안 책임 추상화 → API 설계에서 요청 및 응답 데이터를 정의하는 기존 방식 그대로 진행 가능했음
- **JWT 기반 인증 시스템: 로그인 시 Access Token 및 Refresh Token 발급, 사용자 권한이 필요한 모든 요청에 토큰 요구하도록 구성**
    - JWT: 인증 토큰, 일종의 ‘이름이 적힌 출입증’ 개념
    - 로그인이란 ID+PW를 주면 서버에서 검증 후, 로그아웃 전까지 서버 기능에 접근할 수 있는 토큰을 발급해주는 과정이라고도 볼 수 있음
    - 서버 내부에서는 토큰을 통해 클라이언트에서 어떤 사용자가 요청했는지 식별 가능
    - 모든 로그인 관련 기능과 사용자 기능은 이 토큰을 요청 시 ‘헤더’에 포함해야 제대로 동작하도록 API 구성 (Authorization: Bearer <access_token>)
- **비밀번호 보안: 자체 회원가입 시 bcrypt 알고리즘으로 해시된 값을 DB에 저장하고, 로그인 시 검증**

**나머지 보안 요소는 서버를 전반적으로 구현한 이후 통합 및 유지보수 단계에서의 확장 및 고도화 과정으로 볼 수 있어서 아직 구체화하지 않음**
- **서버 내부 데이터 흐름 통제 (애플리케이션 계층 보안)**
- **배포 및 유지보수 보안 점검 (운영 및 환경 보안)**